// -- user code here --

/* --- start generated code --- */

// Generated by  1.4.4 (Phaser v2.6.2)


/**
 * Paddle
 * @param {Phaser.Game} aGame A reference to the currently running game.
 * @param {Number} aX The x coordinate (in world space) to position the Sprite at.
 * @param {Number} aY The y coordinate (in world space) to position the Sprite at.
 * @param {any} aKey This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
 * @param {any} aFrame If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
 */
function Paddle(aGame, aX, aY, aKey, aFrame) {
	Phaser.Sprite.call(this, aGame, aX, aY, aKey || 'textures', aFrame == undefined || aFrame == null? 'bar' : aFrame);
	this.anchor.setTo(0.5, 0.0);
	this.game.physics.arcade.enable(this);
	this.body.immovable = true;
	
	this.afterCreate();
	
}

/** @type Phaser.Sprite */
var Paddle_proto = Object.create(Phaser.Sprite.prototype);
Paddle.prototype = Paddle_proto;
Paddle.prototype.constructor = Paddle;

/* --- end generated code --- */

Paddle.prototype.afterCreate = function() {
	this.keys = this.game.input.keyboard.createCursorKeys();
	this.weapon = this.game.add.weapon(10, "textures", "weapon");
	this.weapon.bulletAngleOffset = 90;
	this.weapon.bulletKillType = Phaser.Weapon.KILL_WORLD_BOUNDS;
	this.weapon.fireRate = 500;
	this.weapon.bulletSpeed = 500;
	this.weapon.autofire = true;
	this.weapon.trackSprite(this, 0, 15);
	this.weapon.autofire = false;
};

Paddle.prototype.update = function() {
	/** @type Level */
	var state = this.game.state.getCurrentState();

	state.physics.arcade.overlap(this, state.objects, this.paddleVsObject);
	state.physics.arcade.overlap(this.weapon.bullets, state.bricks,
			this.bulletVsBrick);

	// by default stop the paddle
	this.body.velocity.set(0);

	this.x = this.game.input.x;
	
	var leftMargin = 50 + this.width / 2;
	if (this.x < leftMargin) {
		this.x = leftMargin;
	}

	var rightMargin = 550 - this.width / 2;
	if (this.x > rightMargin) {
		this.x = rightMargin;
	}

	if (this.weapon.autofire) {
		if (this.game.time.now > this.weaponStopTime) {
			this.weapon.autofire = false;
		}
	}
};

/**
 * 
 * @param {Phaser.Sprite}
 *            bullet
 * @param {BaseBrick}
 *            brick
 */
Paddle.prototype.bulletVsBrick = function(bullet, brick) {
	bullet.kill();
	brick.breakMe();
};

/**
 * 
 * @param {Ball}
 *            paddle
 * @param {BaseObject}
 *            obj
 */
Paddle.prototype.paddleVsObject = function(paddle, obj) {
	obj.takeMe();
};

Paddle.prototype.fireWeapon = function() {
	this.weapon.autofire = true;
	this.weaponStopTime = this.game.time.now + 1000000;
};

Paddle.prototype.stopWeapon = function() {
	this.weapon.autofire = false;
	this.weapon.killAll();
};
