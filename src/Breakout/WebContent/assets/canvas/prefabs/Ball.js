// -- user code here --

/* --- start generated code --- */

// Generated by  1.4.3 (Phaser v2.6.2)


/**
 * Ball
 * @param {Phaser.Game} aGame A reference to the currently running game.
 * @param {Number} aX The x coordinate (in world space) to position the Sprite at.
 * @param {Number} aY The y coordinate (in world space) to position the Sprite at.
 * @param {any} aKey This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.
 * @param {any} aFrame If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.
 */
function Ball(aGame, aX, aY, aKey, aFrame) {
	Phaser.Sprite.call(this, aGame, aX, aY, aKey || 'textures', aFrame == undefined || aFrame == null? 'ball' : aFrame);
	this.anchor.setTo(0.5, 0.5);
	this.game.physics.arcade.enable(this);
	this.body.bounce.x = 1.0;
	this.body.bounce.y = 1.0;
	this.body.maxVelocity.x = 300.0;
	this.body.maxVelocity.y = 300.0;
	
}

/** @type Phaser.Sprite */
var Ball_proto = Object.create(Phaser.Sprite.prototype);
Ball.prototype = Ball_proto;
Ball.prototype.constructor = Ball;

/* --- end generated code --- */

Ball.prototype.toPlace = function() {
	/** @type Level */
	var state = this.game.state.getCurrentState();

	var paddle = state.fPaddle;

	this.x = paddle.centerX - 15;
	this.y = paddle.y - 50;

	this.body.velocity.set(0);
	this.alpha = 0;

	// fade-in the ball
	state.add.tween(this).to({
		alpha : 1
	}, 1000, "Linear", true)

	// when the tween is complete set the ball velocity
	.onComplete.add(function() {
		this.body.velocity.set(-75, -300);
	}, this);
};

Ball.prototype.update = function() {
	/** @type Level */
	var state = this.game.state.getCurrentState();

	state.physics.arcade.collide(this, state.fTubes);
	state.physics.arcade.collide(this, state.fPaddle, this.ballVsBar, null, this);
	state.physics.arcade.collide(this, state.bricks, this.ballVsBrick, null,
			this);	

	this.angle += this.body.speed * -Math.sign(this.body.velocity.x) * 0.1;	
};

/**
 * 
 * @param {Ball}
 *            ball
 * @param {Bar}
 *            paddle
 */
Ball.prototype.ballVsBar = function(ball, paddle) {
	if (ball.x < paddle.x) {
		// Ball is on the left-hand side of the paddle
		var diff = paddle.x - ball.x;
		ball.body.velocity.x = (-10 * diff);
	} else if (ball.x > paddle.x) {
		// Ball is on the right-hand side of the paddle
		var diff = ball.x - paddle.x;
		ball.body.velocity.x = (10 * diff);
	} else {
		// Ball is perfectly in the middle
		// Add a little random X to stop it bouncing straight up!
		ball.body.velocity.x = 2 + Math.random() * 8;
	}
};

/**
 * 
 * @param {Phaser.Sprite}
 *            ball
 * @param {Brick}
 *            brick
 */
Ball.prototype.ballVsBrick = function(ball, brick) {
	if (brick.broken) {
		return;
	}

	brick.breakMe();
};
